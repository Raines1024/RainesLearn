# 算法的时间复杂度

## 基本概念
算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。

那么当我们拿到算法的执行次数函数 T(n) 之后怎么得到算法的时间复杂度呢？

1.我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。

2.我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。

3.因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

综合起来：如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。为了方便描述，下文称此为 大O推导法。

由此可见，由执行次数 T(n) 得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。

1.对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个
  循环的时间复杂度为 O(n×m)。

2.对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该由里向外分析这些循环。

3.对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

4.对于条件判断语句，总的时间复杂度等于其中 时间复杂度最大的路径 的时间复杂度。

## 练习题
    void aFunc(int n) {
        for (int i = 0; i < n; i++) {
            for (int j = i; j < n; j++) {
                printf("Hello World\n");
            }
        }
    }

参考答案：
 当 i = 0 时，内循环执行 n 次运算，当 i = 1 时，内循环执行 n - 1 次运算……当 i = n - 1 时，内循环执行 1 次运算。
 所以，执行次数 T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2。
 根据上文说的 大O推导法 可以知道，此时时间复杂度为 O(n^2)。
 
 
     void aFunc(int n) {
         for (int i = 2; i < n; i++) {
             i *= 2;
             printf("%i\n", i);
         }
     }
 
 参考答案：
 假设循环次数为 t，则循环条件满足 2^t < n。
 可以得出，执行次数t = log(2)(n)，即 T(n) = log(2)(n)，可见时间复杂度为 O(log(2)(n))，即 O(log n)。
 
     long aFunc(int n) {
         if (n <= 1) {
             return 1;
         } else {
             return aFunc(n - 1) + aFunc(n - 2);
         }
     }
 
 参考答案：
 显然运行次数，T(0) = T(1) = 1，同时 T(n) = T(n - 1) + T(n - 2) + 1，这里的 1 是其中的加法算一次执行。
 显然 T(n) = T(n - 1) + T(n - 2) 是一个斐波那契数列，通过归纳证明法可以证明，当 n >= 1 时 T(n) < (5/3)^n，同时当 n > 4 时 T(n) >= (3/2)^n。
 所以该方法的时间复杂度可以表示为 O((5/3)^n)，简化后为 O(2^n)。






























